## 根据自检清单 每日一记

来自 [一名【合格】前端工程师的自检清单](https://mp.weixin.qq.com/s?__biz=MzAwNDcyNjI3OA==&mid=2650842922&idx=1&sn=9430980473c8b55de16f13ec47b6cba9&chksm=80d38c43b7a40555c2bc3ae5801d554145ec547a0a2cea34d4ecd60f11eed6f94c59a4a05d9f&scene=0&xtrack=1&key=f8a21a8df9909cbbceeacb33f9612d5cb45858249099c33a4ecfa99ad453c192c27a62acbd22a496f9949636e9778ff013d7e2555ad88e403a664bb3955a1584c157ee34db81e5d55b2c34de354551aa&ascene=1&uin=MjkwNDAwMTQzNw%3D%3D&devicetype=Windows+10&version=62060833&lang=zh_CN&pass_ticket=FzRfPh7EJrl07iw1IJdj%2BlRCbQd9zm6HJh8Nfwg4xmawW9Z27DcogAEmNcixiGwc##)

## 一、JavaScript基础

### 1.JavaScript基础
* JavaScript规定了几种语言类型

	<font color=#eea236>Boolean、Null、Undefined、Number、String、Object、Symbol (ES6 引入新的原始数据类型)</font>
	   
	   原始/值数据类型：变量是存放在栈区的（栈区指内存里的栈内存）
		    简单的数据段。按值访问，可以操作保存在变量中实际的值。（null、undefined特殊）
			* Boolean: 布尔
			* Null: 空值 空对象/对象不存在 
				表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。
			* Undefined: 缺失值
				所有已声明但是没有初始化的变量，默认值都为undefined。
				函数没有明确返回值的时候，会默认返回undefined。
				调用函数时应该提供的参数还没有提供，该参数就等于undefined
				对象没有赋值的属性，该属性的值就等于undefined
			* Number: 数字
			* String: 字符串
			* Symbol: Symbol值通过symbol函数生成,表示独一无二的值
		
		引用/对象数据类型：值是同时保存在栈内存和堆内存中的对象
			有多个值构成的对象。引用类型的值是按引用访问的。JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间,只能操作对象在栈内存中的引用地址。
			* Object: 对象类型 例如：Object 、Array 、Function 、Data等
			
	思考1:  [js 基本类型与引用类型的区别一](https://www.cnblogs.com/focusxxxxy/p/6390536.html)
	
	以下总结摘自: [js 基本类型与引用类型的区别二](https://www.cnblogs.com/cxying93/p/6106469.html)   
	
		总结区别
		
		　　a 声明变量时不同的内存分配：　
		
		　　1）原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。
		
		　　　　这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。
		
		　　2）引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。
		
		　　　  这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。
		
		　　　  地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。
		
		　　b 不同的内存分配机制也带来了不同的访问机制
		　　　
		　　1）在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，
		　　　　首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。
		　　2）而原始类型的值则是可以直接访问到的。
		　　
		　　c 复制变量时的不同
		　　
		　　1）原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。
		　　2）引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，
		　　　　也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。
		　　　　（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）。多了一个指针
		　
		　　d 参数传递的不同（把实参复制给形参的过程）
		　　
		　　首先我们应该明确一点：ECMAScript中所有函数的参数都是按值来传递的。
		　　但是为什么涉及到原始类型与引用类型的值时仍然有区别呢？还不就是因为内存分配时的差别。 　
		　　1）原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。
		　　2）引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！
		　　　　因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。
	
	思考2: 如何判断数据类型 ？
	
	[判断JS数据类型的四种方法](https://www.cnblogs.com/onepixel/p/5126046.html)
	
* JavaScript对象的底层数据结构是什么

* Symbol类型在实际开发中的应用、可手动实现一个简单的 Symbol

* JavaScript中的变量在内存中的具体存储形式

* 基本类型对应的内置对象，以及他们之间的装箱拆箱操作

* 理解值类型和引用类型

* null和 undefined的区别

		Null: 空值 空对象/对象不存在 
			表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。作为函数参数，表示该函数的参数不是对象
				
			作为对象原型链的终点
```js
	Object.getPrototypeOf(Object.prototype)
```
				
		Undefined: 缺失值
		
				所有已声明但是没有初始化的变量，默认值都为undefined。
```js
	let a
```
				函数没有明确返回值的时候，会默认返回undefined。
```js
	var x = f();
```
				调用函数时应该提供的参数还没有提供，该参数就等于undefined
```js
	function f(x){console.log(x)}
```
				对象没有赋值的属性，该属性的值就等于undefined
```js
	var  o = new Object();
	o.p 
```
* 至少可以说出三种判断 JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型

* 可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用

* 出现小数精度丢失的原因， JavaScript可以存储的最大数字、最大安全数字， JavaScript处理大数字的方法、避免精度丢失的方法


### 2.原型和原型链

* 理解原型设计模式以及 JavaScript中的原型规则

* instanceof的底层实现原理，手动实现一个 instanceof

* 实现继承的几种方式以及他们的优缺点

* 至少说出一种开源项目(如 Node)中应用原型继承的案例

* 可以描述 new一个对象的详细过程，手动实现一个 new操作符

* 理解 es6class构造以及继承的底层实现原理


### 3.作用域和闭包

* 理解词法作用域和动态作用域

* 理解 JavaScript的作用域和作用域链

* 理解 JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题

* this的原理以及几种不同使用场景的取值

* 闭包的实现原理和作用，可以列举几个开发中闭包的实际应用

* 理解堆栈溢出和内存泄漏的原理，如何防止

* 如何处理循环的异步操作

* 理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理

### 4.执行机制

* 为何 try里面放 return， finally还会执行，理解其内部机制

* JavaScript如何实现异步编程，可以详细描述 EventLoop机制

* 宏任务和微任务分别有哪些

* 可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法

* 使用 Promise实现串行

* Node与浏览器 EventLoop的差异

* 如何在保证页面运行流畅的情况下处理海量数据

### 5.语法和API

* 理解 ECMAScript和 JavaScript的关系

* 熟练运用 es5、 es6提供的语法规范

* 熟练掌握 JavaScript提供的全局对象（例如 Date、 Math）、全局函数（例如 decodeURI、 isNaN）、全局属性（例如 Infinity、 undefined）

* 熟练应用 map、 reduce、 filter 等高阶函数解决问题

* setInterval需要注意的点，使用 settimeout实现 setInterval

* JavaScript提供的正则表达式 API、可以使用正则表达式（邮箱校验、 URL解析、去重等）解决常见问题

* JavaScript异常处理的方式，统一的异常处理方案


## 二、HTML和CSS
### 1.HTML

* 从规范的角度理解 HTML，从分类和语义的角度使用标签

* 常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式

* 元信息类标签( head、 title、 meta)的使用目的和配置方法

* HTML5离线缓存原理

* 可以使用 CanvasAPI、 SVG等绘制高性能的动画

### 2.CSS

* CSS盒模型，在不同浏览器的差异

* CSS所有选择器及其优先级、使用场景，哪些可以继承，如何运用 at规则

* CSS伪类和伪元素有哪些，它们的区别和实际应用

* HTML文档流的排版规则， CSS几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理

* 水平垂直居中的方案、可以实现 6种以上并对比它们的优缺点

* BFC实现原理，可以解决的问题，如何创建 BFC7.可使用 CSS函数复用代码，实现特殊效果

* PostCSS、 Sass、 Less的异同，以及使用配置，至少掌握一种

* CSS模块化方案、如何配置按需加载、如何防止 CSS阻塞渲染

* 熟练使用 CSS实现常见动画，如渐变、移动、旋转、缩放等等

* CSS浏览器兼容性写法，了解不同 API在不同浏览器下的兼容性情况

* 掌握一套完整的响应式布局方案

### 3.手写

* 手写图片瀑布流效果

* 使用 CSS绘制几何图形（圆形、三角形、扇形、菱形等）

* 使用纯 CSS实现曲线运动（贝塞尔曲线）

* 实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点

## 三、计算机基础

### 1.编译原理

* 理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序

* 正则表达式的匹配原理和性能优化

* 如何将 JavaScript代码解析成抽象语法树( AST)

* base64的编码原理

* 几种进制的相互转换计算方法，在 JavaScript中如何表示和转换

### 2.网络协议

* 理解什么是协议，了解 TCP/IP网络协议族的构成，每层协议在应用程序中发挥的作用

* 三次握手和四次挥手详细原理，为什么要使用这种机制

* 有哪些协议是可靠， TCP有哪些手段保证可靠交付

* DNS的作用、 DNS解析的详细过程， DNS优化原理

* CDN的作用和原理

* HTTP请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么

* HTTP所有状态码的具体含义，看到异常状态码能快速定位问题

* HTTP1.1、 HTTP2.0带来的改变

* HTTPS的加密原理，如何开启 HTTPS，如何劫持 HTTPS请求

* 理解 WebSocket协议的底层原理、与 HTTP的区别

### 3.设计模式

* 熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等

* 发布订阅模式和观察者模式的异同以及实际应用

* 可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用
## 四、数据结构和算法
## 五、运行环境
## 六、框架和类库
## 七、前端工程
## 八、项目和业务
## 九、学习提升
## 十、技术之外