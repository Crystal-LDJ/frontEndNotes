## 根据自检清单 每日一记

来自 [一名【合格】前端工程师的自检清单](https://mp.weixin.qq.com/s?__biz=MzAwNDcyNjI3OA==&mid=2650842922&idx=1&sn=9430980473c8b55de16f13ec47b6cba9&chksm=80d38c43b7a40555c2bc3ae5801d554145ec547a0a2cea34d4ecd60f11eed6f94c59a4a05d9f&scene=0&xtrack=1&key=f8a21a8df9909cbbceeacb33f9612d5cb45858249099c33a4ecfa99ad453c192c27a62acbd22a496f9949636e9778ff013d7e2555ad88e403a664bb3955a1584c157ee34db81e5d55b2c34de354551aa&ascene=1&uin=MjkwNDAwMTQzNw%3D%3D&devicetype=Windows+10&version=62060833&lang=zh_CN&pass_ticket=FzRfPh7EJrl07iw1IJdj%2BlRCbQd9zm6HJh8Nfwg4xmawW9Z27DcogAEmNcixiGwc##)

## 一、JavaScript基础

### 1.JavaScript基础
* JavaScript规定了几种语言类型

	<font color=#eea236>Boolean、Null、Undefined、Number、String、Object、Symbol (ES6 引入新的原始数据类型)</font>
	   
	   原始/值数据类型：变量是存放在栈区的（栈区指内存里的栈内存）
		    简单的数据段。按值访问，可以操作保存在变量中实际的值。（null、undefined特殊）
			* Boolean: 布尔
			* Null: 空值 空对象/对象不存在 
				表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。
			* Undefined: 缺失值
				所有已声明但是没有初始化的变量，默认值都为undefined。
				函数没有明确返回值的时候，会默认返回undefined。
				调用函数时应该提供的参数还没有提供，该参数就等于undefined
				对象没有赋值的属性，该属性的值就等于undefined
			* Number: 数字
			* String: 字符串
			* Symbol: Symbol值通过symbol函数生成,表示独一无二的值
		
		引用/对象数据类型：值是同时保存在栈内存和堆内存中的对象
			有多个值构成的对象。引用类型的值是按引用访问的。JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间,只能操作对象在栈内存中的引用地址。
			* Object: 对象类型 例如：Object 、Array 、Function 、Data等
			
	思考1:  [js 基本类型与引用类型的区别一](https://www.cnblogs.com/focusxxxxy/p/6390536.html)
	
	以下总结摘自: [js 基本类型与引用类型的区别二](https://www.cnblogs.com/cxying93/p/6106469.html)   
	
		总结区别
		
		　　a 声明变量时不同的内存分配：　
		
		　　1）原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。
		
		　　　　这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。
		
		　　2）引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。
		
		　　　  这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。
		
		　　　  地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。
		
		　　b 不同的内存分配机制也带来了不同的访问机制
		　　　
		　　1）在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，
		　　　　首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。
		　　2）而原始类型的值则是可以直接访问到的。
		　　
		　　c 复制变量时的不同
		　　
		　　1）原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。
		　　2）引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，
		　　　　也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。
		　　　　（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）。多了一个指针
		　
		　　d 参数传递的不同（把实参复制给形参的过程）
		　　
		　　首先我们应该明确一点：ECMAScript中所有函数的参数都是按值来传递的。
		　　但是为什么涉及到原始类型与引用类型的值时仍然有区别呢？还不就是因为内存分配时的差别。 　
		　　1）原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。
		　　2）引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！
		　　　　因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。
	
	思考2: 如何判断数据类型？
	
	[判断JS数据类型的四种方法](https://www.cnblogs.com/onepixel/p/5126046.html)
	
* JavaScript对象的底层数据结构是什么

* Symbol类型在实际开发中的应用、可手动实现一个简单的 Symbol

* JavaScript中的变量在内存中的具体存储形式

* 基本类型对应的内置对象，以及他们之间的装箱拆箱操作

* 理解值类型和引用类型

* null和 undefined的区别

		Null: 空值 空对象/对象不存在 
			表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。作为函数参数，表示该函数的参数不是对象
				
			作为对象原型链的终点
		
			Object.getPrototypeOf(Object.prototype)		
				
		Undefined: 缺失值
		
				所有已声明但是没有初始化的变量，默认值都为undefined。

				let a

				函数没有明确返回值的时候，会默认返回undefined。

				var x = f();

				调用函数时应该提供的参数还没有提供，该参数就等于undefined

				function f(x){console.log(x)}

				对象没有赋值的属性，该属性的值就等于undefined

				var  o = new Object();
				o.p 

* 至少可以说出三种判断 JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型

* 可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用

* 出现小数精度丢失的原因， JavaScript可以存储的最大数字、最大安全数字， JavaScript处理大数字的方法、避免精度丢失的方法


### 2.原型和原型链

* 理解原型设计模式以及 JavaScript中的原型规则

* instanceof的底层实现原理，手动实现一个 instanceof

* 实现继承的几种方式以及他们的优缺点

* 至少说出一种开源项目(如 Node)中应用原型继承的案例

* 可以描述 new一个对象的详细过程，手动实现一个 new操作符

* 理解 es6class构造以及继承的底层实现原理


### 3.作用域和闭包

* 理解词法作用域和动态作用域

* 理解 JavaScript的作用域和作用域链

* 理解 JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题

* this的原理以及几种不同使用场景的取值

* 闭包的实现原理和作用，可以列举几个开发中闭包的实际应用

* 理解堆栈溢出和内存泄漏的原理，如何防止

* 如何处理循环的异步操作

* 理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理

### 4.执行机制

* 为何 try里面放 return， finally还会执行，理解其内部机制

* JavaScript如何实现异步编程，可以详细描述 EventLoop机制

* 宏任务和微任务分别有哪些

* 可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法

* 使用 Promise实现串行

* Node与浏览器 EventLoop的差异

* 如何在保证页面运行流畅的情况下处理海量数据

### 5.语法和API

* 理解 ECMAScript和 JavaScript的关系

* 熟练运用 es5、 es6提供的语法规范

* 熟练掌握 JavaScript提供的全局对象（例如 Date、 Math）、全局函数（例如 decodeURI、 isNaN）、全局属性（例如 Infinity、 undefined）

* 熟练应用 map、 reduce、 filter 等高阶函数解决问题

* setInterval需要注意的点，使用 settimeout实现 setInterval

* JavaScript提供的正则表达式 API、可以使用正则表达式（邮箱校验、 URL解析、去重等）解决常见问题

* JavaScript异常处理的方式，统一的异常处理方案


## 二、HTML和CSS

### 1.HTML

* 从规范的角度理解 HTML，从分类和语义的角度使用标签

* 常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式

* 元信息类标签( head、 title、 meta)的使用目的和配置方法

* HTML5离线缓存原理

* 可以使用 CanvasAPI、 SVG等绘制高性能的动画

### 2.CSS

* CSS盒模型，在不同浏览器的差异

* CSS所有选择器及其优先级、使用场景，哪些可以继承，如何运用 at规则

* CSS伪类和伪元素有哪些，它们的区别和实际应用

* HTML文档流的排版规则， CSS几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理

* 水平垂直居中的方案、可以实现 6种以上并对比它们的优缺点

* BFC实现原理，可以解决的问题，如何创建 BFC7.可使用 CSS函数复用代码，实现特殊效果

* PostCSS、 Sass、 Less的异同，以及使用配置，至少掌握一种

* CSS模块化方案、如何配置按需加载、如何防止 CSS阻塞渲染

* 熟练使用 CSS实现常见动画，如渐变、移动、旋转、缩放等等

* CSS浏览器兼容性写法，了解不同 API在不同浏览器下的兼容性情况

* 掌握一套完整的响应式布局方案

### 3.手写

* 手写图片瀑布流效果

* 使用 CSS绘制几何图形（圆形、三角形、扇形、菱形等）

* 使用纯 CSS实现曲线运动（贝塞尔曲线）

* 实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点

## 三、计算机基础

### 1.编译原理

* 理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序

* 正则表达式的匹配原理和性能优化

* 如何将 JavaScript代码解析成抽象语法树( AST)

* base64的编码原理

* 几种进制的相互转换计算方法，在 JavaScript中如何表示和转换

### 2.网络协议

* 理解什么是协议，了解 TCP/IP网络协议族的构成，每层协议在应用程序中发挥的作用

* 三次握手和四次挥手详细原理，为什么要使用这种机制

* 有哪些协议是可靠， TCP有哪些手段保证可靠交付

* DNS的作用、 DNS解析的详细过程， DNS优化原理

* CDN的作用和原理

* HTTP请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么

* HTTP所有状态码的具体含义，看到异常状态码能快速定位问题

* HTTP1.1、 HTTP2.0带来的改变

* HTTPS的加密原理，如何开启 HTTPS，如何劫持 HTTPS请求

* 理解 WebSocket协议的底层原理、与 HTTP的区别

### 3.设计模式

* 熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等

* 发布订阅模式和观察者模式的异同以及实际应用

* 可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用


## 四、数据结构和算法

### 1.JavaScript编码能力

* 多种方式实现数组去重、扁平化、对比优缺点


* 多种方式实现深拷贝、对比优缺点


* 手写函数柯里化工具函数、并理解其应用场景和优势


* 手写防抖和节流工具函数、并理解其内部原理和应用场景


* 实现一个 sleep函数

### 2.手动实现前端轮子

* 手动实现 call、apply、bind


* 手动实现符合 Promise/A+规范的 Promise、手动实现 asyncawait


* 手写一个 EventEmitter实现事件发布、订阅


* 可以说出两种实现双向绑定的方案、可以手动实现


* 手写 JSON.stringify、 JSON.parse


* 手写一个模版引擎，并能解释其中原理


* 手写 懒加载、 下拉刷新、 上拉加载、 预加载等效果

### 3.数据结构

* 理解常见数据结构的特点，以及他们在不同场景下使用的优缺点


* 理解 数组、 字符串的存储原理，并熟练应用他们解决问题


* 理解 二叉树、 栈、 队列、 哈希表的基本结构和特点，并可以应用它解决问题


* 了解 图、 堆的基本结构和使用场景

### 4.算法

* 可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗


* 至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度


* 了解递归和循环的优缺点、应用场景、并可在开发中熟练应用


* 可应用 回溯算法、 贪心算法、 分治算法、 动态规划等解决复杂问题


* 前端处理海量数据的算法方案



## 五、运行环境

### 1.浏览器API

* 浏览器提供的符合 W3C标准的 DOM操作 API、浏览器差异、兼容性


* 浏览器提供的浏览器对象模型 ( BOM)提供的所有全局 API、浏览器差异、兼容性


* 大量 DOM操作、海量数据的性能优化(合并操作、 Diff、 requestAnimationFrame等)


* 浏览器海量数据存储、操作性能优化


* DOM事件流的具体实现机制、不同浏览器的差异、事件代理


* 前端发起网络请求的几种方式及其底层实现、可以手写原生 ajax、 fetch、可以熟练使用第三方库


* 浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型


* 浏览器提供的几种存储机制、优缺点、开发中正确的选择


* 浏览器跨标签通信


### 2.浏览器原理

* 各浏览器使用的 JavaScript引擎以及它们的异同点、如何在代码中进行区分


* 请求数据到请求结束与服务器进行了几次交互


* 可详细描述浏览器从输入 URL到页面展现的详细过程


* 浏览器解析 HTML代码的原理，以及构建 DOM树的流程


* 浏览器如何解析 CSS规则，并将其应用到 DOM树上


* 浏览器如何将解析好的带有样式的 DOM树进行绘制


* 浏览器的运行机制，如何配置资源异步同步加载


* 浏览器回流与重绘的底层原理，引发原因，如何有效避免


* 浏览器的垃圾回收机制，如何避免内存泄漏


* 浏览器采用的缓存方案，如何选择和控制合适的缓存方案


### 3.Node

* 理解 Node在应用程序中的作用，可以使用 Node搭建前端运行环境、使用 Node操作文件、操作数据库等等


* 掌握一种 Node开发框架，如 Express， Express和 Koa的区别


* 熟练使用 Node提供的 API如 Path、 Http、 ChildProcess等并理解其实现原理



* Node的底层运行原理、和浏览器的异同


* Node事件驱动、非阻塞机制的实现原理


##  六、框架和类库

### 1.TypeScript

* 理解 泛型、 接口等面向对象的相关概念， TypeScript对面向对象理念的实现


* 理解使用 TypeScript的好处，掌握 TypeScript基础语法


* TypeScript的规则检测原理


* 可以在 React、 Vue等框架中使用 TypeScript进行开发

### 2.React

* React和 vue选型和优缺点、核心架构的区别


* React中 setState的执行机制，如何有效的管理状态



* React的事件底层实现机制


* React的虚拟 DOM和 Diff算法的内部实现


* React的 Fiber工作原理，解决了什么问题


* ReactRouter和 VueRouter的底层实现原理、动态加载实现原理


* 可熟练应用 ReactAPI、生命周期等，可应用 HOC、 render props、 Hooks等高阶用法解决问题


* 基于 React的特性和原理，可以手动实现一个简单的 React

### 3.Vue

* 熟练使用 Vue的 API、生命周期、钩子函数


* MVVM框架设计理念


* Vue双向绑定实现原理、 Diff算法的内部实现


* Vue的事件机制


* 从 template转换成真实 DOM的实现机制

### 4.多端开发

* 单页面应用（ SPA）的原理和优缺点，掌握一种快速开发 SPA的方案


* 理解 Viewport、 em、 rem的原理和用法，分辨率、 px、 ppi、 dpi、 dp的区别和实际应用


* 移动端页面适配解决方案、不同机型适配方案


* 掌握一种 JavaScript移动客户端开发技术，如 ReactNative：可以搭建 ReactNative开发环境，熟练进行开发，可理解 ReactNative的运作原理，不同端适配


* 掌握一种 JavaScript PC客户端开发技术，如 Electron：可搭建 Electron开发环境，熟练进行开发，可理解 Electron的运作原理


* 掌握一种小程序开发框架或原生小程序开发


* 理解多端框架的内部实现原理，至少了解一个多端框架的使用

### 5.数据流管理

* 掌握 React和 Vue传统的跨组件通信方案，对比采用数据流管理框架的异同


* 熟练使用 Redux管理数据流，并理解其实现原理，中间件实现原理


* 熟练使用 Mobx管理数据流，并理解其实现原理，相比 Redux有什么优势


* 熟练使用 Vuex管理数据流，并理解其实现原理


* 以上数据流方案的异同和优缺点，不情况下的技术选型

### 6.实用库

* 至少掌握一种 UI组件框架，如 antd design，理解其设计理念、底层实现


* 掌握一种图表绘制框架，如 Echart，理解其设计理念、底层实现，可以自己实现图表


* 掌握一种 GIS开发框架，如百度地图 API


* 掌握一种可视化开发框架，如 Three.js、 D3


* 工具函数库，如 lodash、 underscore、 moment等，理解使用的工具类或工具函数的具体实现原理


## 七、前端工程

### 1.项目构建

* 理解 npm、 yarn依赖包管理的原理，两者的区别

* 可以使用 npm运行自定义脚本

* 理解 Babel、 ESLint、 webpack等工具在项目中承担的作用

* ESLint规则检测原理，常用的 ESLint配置

* Babel的核心原理，可以自己编写一个 Babel插件

* 可以配置一种前端代码兼容方案，如 Polyfill

*  Webpack的编译原理、构建流程、热更新原理， chunk、 bundle和 module的区别和应用

* 可熟练配置已有的 loaders和 plugins解决问题，可以自己编写 loaders和 plugins

### 2.nginx

* 正向代理与反向代理的特点和实例
    
   正向代理特点：客户端非常明确要访问的服务器地址。正向代理模式屏蔽或者隐藏了真是客户端信息
   
   用途：
   
    1.访问原来无法访问的资源，如Google

    2.可以做缓存，加速访问资源

    3.对客户端访问授权，上网进行认证

    4.代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息
    
    反向代理对外是透明的，访问者并不知道直接访问的一个代理。所以客户端不需要任何配置就可以访问
    
    用途：
    
    保证内网的安全，通常将反向代理作为公网访问地址，Web服务器是内网

负载均衡，通过反向代理服务器来优化网站的负载
    

* 可手动搭建一个简单的 nginx服务器、

* 熟练应用常用的 nginx内置变量，掌握常用的匹配规则写法

* 可以用 nginx实现请求过滤、配置 gzip、负载均衡等，并能解释其内部原理

### 3.开发提速

* 熟练掌握一种接口管理、接口 mock工具的使用，如 yapi

* 掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题

* 理解 TDD与 BDD模式，至少会使用一种前端单元测试框架

### 4.版本控制

* 理解 Git的核心原理、工作流程、和 SVN的区别
	
Git的核心原理

	(本地)
	1.工作区：当前进行工作区域，是文件系统的概念	 工作目录就是执行git init的地方
	2.暂存区：记录下次要提交将要保存到版本库中的文件  在.git 目录下
	3.版本库：记录工程某次提交的完整状态和内容，意味着该数据永远不会丢失 在.git 目录下
	
	所有文件只处于其中一个状态（本地）
	已修改 (modified)： 表示已修改但是没有保存到数据库，处于本地的工作区
	已暂存(staged)： 表示对已修改的文件的当前版本做标识，让它包含在下一次提交的快照中 ，处于暂存区
	已提交(committed)： 表示完成修改并保存到本地数据库中，处于已提交域
	
	处理结束再将本地仓库的最新状态文件快照 推送到远程仓库	(中心服务器)
	

Git的工作流程

	1.在本地工作区/工作目录中修改文件，文件modified
	2.暂存文件，add 把文件快照放入暂存区域，处于等待状态
	3.commit并push 找到暂存区域文件，并将快照永久性的存储到Git远程仓库

Git和 SVN的区别
	
	1.非集中式存储
	
	传统的SVN(集中式版本控制)要依赖特定的服务器实现版本管理功能，SVN必须联网才能正常工作。如果宕机一段时间 服务器崩溃情况 在这期间开发很难正在工作的版本上合作或者保存某一个版本的改变，或者中央数据库的磁盘出现问题但是没有备份导致丢失文件。解决方案把所有人的本地代码合并得到完整的版本但是将会会丢失历史版本/日志。
	
	
	Git (分布式版本控制) 不依赖特定的服务器完成功能 客户端不仅仅是检查文件的最新快照[完全镜像的存储库也就是本地有仓库]所以如果出现一样的情况，任何一个客户端仓库都可以备份到服务器来恢复数据。所以每一个clone是所有数据的完整备份 除了没有push的代码。另外Git 是支持离线工作，在本地可以进行很多操作，例如提交文件，查看历史版本记录，分支功能等。
	
	2.分支方面
	
	在版本管理方面，分支是最常见的使用功能。例如开发分支，稳定分支等等
	
	SVN 是没有本地分支。在SVN中分支就是一个完整的目录，且这个目录有完整的实际文件。如果想知道是否合并某一个分支 只需要手动运行 命令svn:mergeinfo 来确认分支是否被合并。而Git 分支是指针指向某次提交,处理Git分支可以在同一个工作目录下快速在几个分支切换。SVN 有一个switch功能，可以在同一个工作树上使用switch 在不同分支切换
	
	3.存储方式
	
	Git把内容按元数据方式存储，SVN 按文件存储。因为.git 目录是除于机器上的一个克隆版的版本库，包含中心版本库所有东西例如分支，版本记录等等。所以.git目录体积大小跟.svn区别很大
	
	4.全局版本号和全球版本号
	
	SVN 具有全局版本号，因为SVN是集中式版本控制所以容易实现版本号的连续性，基本可以预判下一个版本号
	
	Git 没有全局版本号，Git是分布式版本控制，Git 采用的是40位长的哈希值作为版本号，每个人的提交都是各自独立完成，也因为提交有先后顺序但是push/pull的时机不一致，所以没有先后之分。另外使用哈希值版本号不会出现重复，保证数据的完整性。因为哈希值是根据内容或者目录结构计算出来的
	
	Git 版本号简化: Git 可以使用从左面开始任意长度的字串作为简化版本号，只要该简化的版本号不产生歧义。一般采用7位的短版本号（只要不会出现重复的，也可以使用更短的版本号）。 Git 还可以使用 tag 来创建别名，即里程碑。
	
	5.版本库和工作区
	
	SVN的版本库和工作区是物理上是分开的，存储在不同的路径上，一般是在不同的主机上。而在企业级部署版本库在服务器上，只能通过协议访问，而不能直接被用户接触到。
	
	Git 的版本库和工作区是在同一个目录，工作区的根目录有一个.git（版本库本身，用来保存元数据和对象数据库的地方）的子目录，每次clone镜像仓库时候，实际copy的就是这个目录的数据。工作区的其他文件为工作区文件。
	版本库可以脱离工作区存在，成为bare版本库，但是工作区不能脱离版本库存在，所以工作区的根目录必须有一个.git的版本库克隆文件。
	因为Git的版本库在工作区能够直接被用户接触，所以用户可以直接修改.git/*文件，例如编辑.git/config 修改配置等，添加.git/ignore 创建本地忽略文件
	
	6.权限管理
	
	SVN 通过对文件目录的授权实现权限管理，子目录默认继承父目录权限。但是权限不能再分支中继承也不能对单个文件授权。
	
	Git授权只有 有或没有的授权。意思要么拥有全部的写权限，要么没有写权限。
	所以关于授权可以通过公司内部代码开放，或者对代码库进行分解，分别授权等
	
	7.操作方面
	
		7.1 checkout
			
		SVN 可以将整个或者部分目录检出到工作区（git 每个子目录下都有单独的.svn目录）
		Git 没有部分检出，但可以通过git工具 去浏览git库的功率。Git-submodule 可以实现版本库的模块化，例如子模块允许将一个git仓库当做另外一个git仓库的子目录。（git的本地仓库信息完全尾货在根目录的.git目录）
		
		7.2 update
		
		SVN 只有一个中心仓库，所以svn update 可以使工作区和版本库保持同步
		Git 通常是开发改动都是在远程仓库上，所以使用git fetch【将远程数据库的obkect copy到locol 然后更新remotes head 的refs】和git pull【在git fetch的基础上对当前分支加merge操作】远程更新
		
		7.3 撤销
		
		SVN 是属于集中式的版本控制，不能允许个人对已提交的数据进行篡改。SVN具有一个非常重要的特性就是它的信息从不丢失，即使当你删除了文件或目录，它也许从最新版本中消失了 ，但这个对象依然存在于历史的早期版本中。所以对远程仓库的数据提交就不能从客户端撤掉，只能在后续的提交中回退或者修改。
		
		Git 是分布式版本控制系统，代码库属于个人，Git可以放弃最新的提交，使用git reset/rebase修改或者重构历史提交
		
		8. 优缺点(https://www.cnblogs.com/wx1993/p/7680877.html)
		
		SVN 优点： 
		
		1、 管理方便，逻辑明确，符合一般人思维习惯。 

		2、 易于管理，集中式服务器更能保证安全性。 

		3、 代码一致性非常高。 

		4、 适合开发人数不多的项目开发。 

		SVN 缺点： 

		1、 服务器压力太大，数据库容量暴增。 

		2、 如果不能连接到服务器上，基本上不可以工作。

		3、 不适合开源开发（开发人数非常非常多，但是Google app engine就是用svn的）。但是一般集中式管理的有非常明确的权限管理机制（例如分支访问限制），可以实现分层管理，从而很好的解决开发人数众多的问题。
		
		
		Git 优点： 

		1、适合分布式开发，强调个体。 

		2、公共服务器压力和数据量都不会太大。 

		3、速度快、灵活。 

		4、任意两个开发者之间可以很容易的解决冲突。 

		5、离线工作。 

		Git 缺点： 

		1、学习周期相对而言比较长。 

		2、不符合常规思维。 

		3、代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。
		
	
* 熟练使用常规的 Git命令、 git rebase、 git stash等进阶命令
		
常规Git命令：
		
		git help(查看帮助命令)
		
		git clone (克隆远程的地址下载到本地)
		
		git init (初始化仓库)
		
		git branch (显示所有分支)
		
		git branch -d <branchname>(删除分支)
		
		git checkout mater (去到master这个分支)
		
		git checkout -b mybranch(创建并切换分支)
				
		git checkout -b mybranch origin/mybranch(取远程分支并分化一个新分支)
		
		git pull origin master(拉取master)
		
		git checkout -b ldj2 (在master下创建一个名为 ldj2的分支)
		
		git checkout -b ldj2 ldj3 (在master下的ldj2分支下创建一个名为ldj3的分支)
		
		git status (查看当前文件状态)
		
		git diff filename （查看filename这个文件做的那些修改）
		
		git add filename (添加要提交的文件)
		
		git commit -m “write you annotation here” (提交，引号里面写注释)
		
		git push(上传本地所有分支代码到远程对应的分支上。)
		
		git push origin master(传本地当前分支代码到master分支)
		
		git merge origin/maste(把远程下载下来的代码合并到本地仓库，远程的和本地的合并)
		
		git remote -v(查询当前远程的版本)
		
		git fetch origin master(从远程获取最新版本到本地)
		
git rebase:(变基其实也是一种合并分支的方法【个人用的特别的少】变基的作用就是修整历史，将分支历史并入主线。)
		
[git rebase使用笔记](https://www.jianshu.com/p/cca69cb695a6)
		
		合并多次提交记录：
		
			git rebase -i HEAD~4 (合并最近的 4 次提交纪录)
			git rebase --edit-todo (去到编辑的模式)
			git rebase --continue (继续编辑 修改保存)
			git log (查看结果)
		
		分支合并：
		
			git:(feature1) git rebase master 
			1. git 会把 feature1 分支里面的每个 commit 取消掉
			2. 上面的操作临时保存成 patch 文件，存在 .git/rebase 目录下
			3. 把 feature1 分支更新到最新的 master 分支；
			4. 把上面保存的 patch 文件应用到 feature1 分支上
			
			在 rebase 的过程中，也许会出现冲突。通常git 会停止 rebase 并去解决冲突。
			在解决完冲突后，用 git add 命令去更新这些内容。
			这时候不需要用git commit 只需要执行 git rebase--continue
			git 会继续应用余下的 patch 补丁文件
			
			任何时候 都可以使用
			git rebase —abort (终止 rebase 的行动，并且分支会回到 rebase 开始前的状态。)
		
git stash:用于保存和恢复工作进度 (这个命令很有效)
		
		git stash(保存当前的工作进度。会分别对暂存区和工作区的状态进行保存)		
				
		git stash save "message..."	(这条命令实际上是第一条 git stash 命令的完整版)	
		
		git stash list(显示进度列表。此命令显然暗示了git stash 可以多次保存工作进度，并用在恢复时候进行选择)	
			
		git stash pop [--index] [<stash>]	(如果不使用任何参数，会恢复最新保存的工作进度，并将恢复的工作进度从存储的工作进度列表中清除。		
		如果提供参数（来自 git stash list 显示的列表），则从该 <stash> 中恢复。恢复完毕也将从进度列表中删除 <stash>。		
		选项--index 除了恢复工作区的文件外，还尝试恢复暂存区。)	
			
		git stash apply [--index] [<stash>]	(除了不删除恢复的进度之外，其余和 git stash pop 命令一样)	
				
		git stash clear	(删除所有存储的进度)
		
		

* 可以快速解决 线上分支回滚、 线上分支错误合并等复杂问题

      线上分支回滚：
        1. 删除远程分支再提交
            
            
        2. 强制push远程分支
            
            
        3. 从回滚位置生成新的commit hash


        4. 从回滚位置生成新的分支merge


### 5.持续集成

* 理解 CI/CD技术的意义，至少熟练掌握一种 CI/CD工具的使用，如 Jenkins

* 可以独自完成架构设计、技术选型、环境搭建、全流程开发、部署上线等一套完整的开发流程（包括 Web应用、移动客户端应用、 PC客户端应用、小程序、 H5等等）

## 八、项目和业务

### 1.后端技能

* 了解后端的开发方式，在应用程序中的作用，至少会使用一种后端语言

* 掌握数据最终在数据库中是如何落地存储的，能看懂表结构设计、表之间的关联，至少会使用一种数据库

### 2.性能优化

* 了解前端性能衡量指标、性能监控要点，掌握一种前端性能监控方案

* 了解常见的 Web、 App性能优化方案

*  SEO排名规则、 SEO优化方案、前后端分离的 SEO

*  SSR实现方案、优缺点、及其性能优化

*  Webpack的性能优化方案

*  Canvas性能优化方案

*  React、 Vue等框架使用性能优化方案

### 3.前端安全

*  XSS攻击的原理、分类、具体案例，前端如何防御

*  CSRF攻击的原理、具体案例，前端如何防御

*  HTTP劫持、页面劫持的原理、防御措施
















### 4.业务相关

* 能理解所开发项目的整体业务形态、业务目标、业务架构，可以快速定位线上业务问题

* 能理解所开发项目整体的技术架构、能快读的根据新需求进行开发规划、能快速根据业务报警、线上日志等定位并解决线上技术问题

* 可以将自己的想法或新技术在业务中落地实践，尽量在团队中拥有一定的不可替代性






