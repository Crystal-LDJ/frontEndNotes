## 根据自检清单 每日一记

来自 [一名【合格】前端工程师的自检清单](https://mp.weixin.qq.com/s?__biz=MzAwNDcyNjI3OA==&mid=2650842922&idx=1&sn=9430980473c8b55de16f13ec47b6cba9&chksm=80d38c43b7a40555c2bc3ae5801d554145ec547a0a2cea34d4ecd60f11eed6f94c59a4a05d9f&scene=0&xtrack=1&key=f8a21a8df9909cbbceeacb33f9612d5cb45858249099c33a4ecfa99ad453c192c27a62acbd22a496f9949636e9778ff013d7e2555ad88e403a664bb3955a1584c157ee34db81e5d55b2c34de354551aa&ascene=1&uin=MjkwNDAwMTQzNw%3D%3D&devicetype=Windows+10&version=62060833&lang=zh_CN&pass_ticket=FzRfPh7EJrl07iw1IJdj%2BlRCbQd9zm6HJh8Nfwg4xmawW9Z27DcogAEmNcixiGwc##)

## 一、JavaScript基础

### 1.JavaScript基础
* JavaScript规定了几种语言类型

	<font color=#eea236>Boolean、Null、Undefined、Number、String、Object、Symbol (ES6 引入新的原始数据类型)</font>
	   
	   原始/值数据类型：变量是存放在栈区的（栈区指内存里的栈内存）
		    简单的数据段。按值访问，可以操作保存在变量中实际的值。（null、undefined特殊）
			* Boolean: 布尔
			* Null: 空值 空对象/对象不存在 
				表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。
			* Undefined: 缺失值
				所有已声明但是没有初始化的变量，默认值都为undefined。
				函数没有明确返回值的时候，会默认返回undefined。
				调用函数时应该提供的参数还没有提供，该参数就等于undefined
				对象没有赋值的属性，该属性的值就等于undefined
			* Number: 数字
			* String: 字符串
			* Symbol: Symbol值通过symbol函数生成,表示独一无二的值
		
		引用/对象数据类型：值是同时保存在栈内存和堆内存中的对象
			有多个值构成的对象。引用类型的值是按引用访问的。JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间,只能操作对象在栈内存中的引用地址。
			* Object: 对象类型 例如：Object 、Array 、Function 、Data等
			
	思考1:  [js 基本类型与引用类型的区别一](https://www.cnblogs.com/focusxxxxy/p/6390536.html)
	
	以下总结摘自: [js 基本类型与引用类型的区别二](https://www.cnblogs.com/cxying93/p/6106469.html)   
	
		总结区别
		
		　　a 声明变量时不同的内存分配：　
		
		　　1）原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。
		
		　　　　这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。
		
		　　2）引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。
		
		　　　  这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。
		
		　　　  地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。
		
		　　b 不同的内存分配机制也带来了不同的访问机制
		　　　
		　　1）在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，
		　　　　首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。
		　　2）而原始类型的值则是可以直接访问到的。
		　　
		　　c 复制变量时的不同
		　　
		　　1）原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。
		　　2）引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，
		　　　　也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。
		　　　　（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）。多了一个指针
		　
		　　d 参数传递的不同（把实参复制给形参的过程）
		　　
		　　首先我们应该明确一点：ECMAScript中所有函数的参数都是按值来传递的。
		　　但是为什么涉及到原始类型与引用类型的值时仍然有区别呢？还不就是因为内存分配时的差别。 　
		　　1）原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。
		　　2）引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！
		　　　　因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。
	
	思考2: 如何判断数据类型？
	
	[判断JS数据类型的四种方法](https://www.cnblogs.com/onepixel/p/5126046.html)
	
* JavaScript对象的底层数据结构是什么 
	
	[从Chrome源码看JS Object的实现](https://zhuanlan.zhihu.com/p/26169639)
	![object 类图](../selfChecking/object.png)
   Object:根父母
   HeadObject:提供存储基本功能
   JSReceiver:用于原型查找
   JSObject: JS Object       FixedArray:实际存储数据的地方
   
	
	

* Symbol类型在实际开发中的应用、可手动实现一个简单的 Symbol

* JavaScript中的变量在内存中的具体存储形式

	具体存储形式  栈内存和堆内存
	JavaScript中的变量分为基本类型和引用类型
	基本类型是保存在栈内存中的简单数据段，值都是用固定的大小，保存在栈空间，按值访问
	引用类型是保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，JavaScript不允许直接访问堆内存的位置，所以操作对象时候，实际是操作对象的引用
	所以当要访问堆内存中的引用数据类型时候，首先从栈中获取该对象的地址引用，然后再从堆内存中获取我们需要的数据
	
  [JavaScript中的变量在内存中的具体存储形式](https://juejin.im/entry/5d233ce9f265da1b8608aadd)
	复制行为：
	基本类型复制
	let a = 20;
	let b = a;
	b = 30;
	console.log(a); // 20
	
	引用类型复制
	let a = { x: 10, y: 20 }
	let b = a;
	b.x = 5;
	console.log(a.x); // 5
	

* 基本类型对应的内置对象，以及他们之间的装箱拆箱操作

* null和 undefined的区别

		Null: 空值 空对象/对象不存在 
			表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。作为函数参数，表示该函数的参数不是对象
				
			作为对象原型链的终点
		
			Object.getPrototypeOf(Object.prototype)		
				
		Undefined: 缺失值
		
				所有已声明但是没有初始化的变量，默认值都为undefined。

				let a

				函数没有明确返回值的时候，会默认返回undefined。

				var x = f();

				调用函数时应该提供的参数还没有提供，该参数就等于undefined

				function f(x){console.log(x)}

				对象没有赋值的属性，该属性的值就等于undefined

				var  o = new Object();
				o.p 

* 至少可以说出三种判断 JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型

* 可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用

* 出现小数精度丢失的原因， JavaScript可以存储的最大数字、最大安全数字， JavaScript处理大数字的方法、避免精度丢失的方法


### 2.原型和原型链

* 理解原型设计模式以及 JavaScript中的原型规则

* instanceof的底层实现原理，手动实现一个 instanceof

* 实现继承的几种方式以及他们的优缺点

		1.原型链继承
			核心：将父类实例作为子类原型
			优点：方法的复用	方法定义在父类的原型上，复用了父类构造函数的方法，如 say 方法
			缺点：创建子类实例时候是不能传参
						子类实例共享了父类构造函数的引用属性，如 arr 属性
		
		
		2.构造函数继承
			核心：将父类构造函数的内容复制给子类的构造函数。这是所有继承中唯一一个不涉及到prototype的继承
			优点：父类的引用属性不会被共享
						子类构建实例时候可以向父类传参
						（与原型链继承完全相反）
			缺点：父类的方法不能复用，子类实例的方法每次都是单独创建
			
	
		3.组合继承
			核心：原型链继承和构造函数继承的组合，兼具两者优点
			优点：父类的方法可以被复用
					 父类的引用属性不会被共享
					 子类构建实例时候可以向父类传参
			缺点：调用两次父类的构造函数，第一次给子类的原型添加父类的name，arr 属性，第二次又给子类的构造函数添加了父类的name，arr属性
						从而覆盖子类原型中的同名参数，这种被覆盖的情况造成性能上的浪费
						
		
		4.寄生继承
			核心：
			优点：
			缺点：
				
		
		5.ES6 class
			核心：
			优点：
			缺点：
				
		
		

* 至少说出一种开源项目(如 Node)中应用原型继承的案例

* 可以描述 new一个对象的详细过程，手动实现一个 new操作符

* 理解 es6 class构造以及继承的底层实现原理


### 3.作用域和闭包

* 理解词法作用域和动态作用域

* 理解 JavaScript的作用域和作用域链

* 理解 JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题

* this的原理以及几种不同使用场景的取值

* 闭包的实现原理和作用，可以列举几个开发中闭包的实际应用

* 理解堆栈溢出和内存泄漏的原理，如何防止

* 如何处理循环的异步操作

* 理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理

### 4.执行机制

* 为何 try里面放 return， finally还会执行，理解其内部机制

* JavaScript如何实现异步编程，可以详细描述 EventLoop机制

* 宏任务和微任务分别有哪些

* 可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法

* 使用 Promise实现串行

* Node与浏览器 EventLoop的差异

* 如何在保证页面运行流畅的情况下处理海量数据

### 5.语法和API

* 理解 ECMAScript和 JavaScript的关系

* 熟练运用 es5、 es6提供的语法规范

* 熟练掌握 JavaScript提供的全局对象（例如 Date、 Math）、全局函数（例如 decodeURI、 isNaN）、全局属性（例如 Infinity、 undefined）

* 熟练应用 map、 reduce、 filter 等高阶函数解决问题

* setInterval需要注意的点，使用 settimeout实现 setInterval

* JavaScript提供的正则表达式 API、可以使用正则表达式（邮箱校验、 URL解析、去重等）解决常见问题

* JavaScript异常处理的方式，统一的异常处理方案


## 二、HTML和CSS

### 1.HTML

* 从规范的角度理解 HTML，从分类和语义的角度使用标签

* 常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式

* 元信息类标签( head、 title、 meta)的使用目的和配置方法

* HTML5离线缓存原理
	
		HTML5 离线缓存原理是通过创建manifest 文件（缓存清单文件.appcache文件）的缓存机制（不是存储技术），通过这个文件上的清单解析离线存储资源
		这些资源就会像cookie一样被存储下来。当网络处于离线状态时候，浏览器就会通过被离线存储的数据进行页面展示
		
		优点：1.离线浏览
				 2.减少服务器负载 浏览器只从服务器下载更新过的或者更改过的资源
				 3.速度 对已缓存的资源加载的更快
				 
				 
		与传统浏览器缓存的区别
		1.离线缓存可以是对整个应用，浏览器缓存则是单个文件
		2.离线缓存可以离线访问依然能打开页面，浏览器缓存不可以
		3.离线缓存能通知浏览器更新资源
		
		
* 可以使用 CanvasAPI、 SVG等绘制高性能的动画

### 2.CSS

* CSS盒模型，在不同浏览器的差异
		
	  不管是IE盒子模型还是W3C盒子标准模型 都是包含 content padding border mragin
		不同的是
		IE  怪异盒子模型   content 宽度 = content内容的宽度 + padding + border
		W3C 标准盒模型 content 宽度 = content内容的宽度 
		所以计算盒子占据的位置
		IE盒子模型解释占据的位置 = content + margin
		W3C 盒子模型解释占据的位置 = content + padding + border + margin
		
		为了避免不同浏览器产生效果不一样，通常我们统一会使用W3C标准盒子模型来 在网页的顶部加上doctype声明
		<!doctype html public "-//w3c//dtd xhtml 1.0 transitional//en" "http://www.w3.org/tr/xhtml1/dtd/xhtml1-transitional.dtd">
		
		box-sizing:"border-box"
		类似于IE怪异盒子模型 假设某个div 中的 css 设置这个属性后，设置的宽度就会包含padding 和 border
		有时候我们设置了宽度，但是通过添加了padding 和border 时候，这个div所占据的真正宽度就会相应的变化，
		这时候我们通过设置box-sizing 那么这个真实的宽度则不会变化，会通过自动调整content的宽度，来保证真实宽度不会变化
		
	
		

* CSS所有选择器及其优先级、使用场景，哪些可以继承，如何运用 at规则

* CSS伪类和伪元素有哪些，它们的区别和实际应用

* HTML文档流的排版规则， CSS几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理

* 水平垂直居中的方案、可以实现 6种以上并对比它们的优缺点

* BFC实现原理，可以解决的问题，如何创建 BFC7.可使用 CSS函数复用代码，实现特殊效果

* PostCSS、 Sass、 Less的异同，以及使用配置，至少掌握一种

* CSS模块化方案、如何配置按需加载、如何防止 CSS阻塞渲染

* 熟练使用 CSS实现常见动画，如渐变、移动、旋转、缩放等等

* CSS浏览器兼容性写法，了解不同 API在不同浏览器下的兼容性情况

* 掌握一套完整的响应式布局方案

### 3.手写

* 手写图片瀑布流效果

* 使用 CSS绘制几何图形（圆形、三角形、扇形、菱形等）

* 使用纯 CSS实现曲线运动（贝塞尔曲线）

* 实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点

## 三、计算机基础

### 1.编译原理

* 理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序

	在通信和信息处理中，代码（code）是指一套转换信息的规则系统，例如将一个字母、单词、声音、图像或手势转换为另一种形式或表达，有时还会缩短或加密以便通过某种信道或存储媒体通信。
	
	
* 正则表达式的匹配原理和性能优化

* 如何将 JavaScript代码解析成抽象语法树( AST)

* base64的编码原理

* 几种进制的相互转换计算方法，在 JavaScript中如何表示和转换

### 2.网络协议

* 理解什么是协议，了解 TCP/IP网络协议族的构成，每层协议在应用程序中发挥的作用

* 三次握手和四次挥手详细原理，为什么要使用这种机制

* 有哪些协议是可靠， TCP有哪些手段保证可靠交付

* DNS的作用、 DNS解析的详细过程， DNS优化原理

* CDN的作用和原理

* HTTP请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么

* HTTP所有状态码的具体含义，看到异常状态码能快速定位问题

* HTTP1.1、 HTTP2.0带来的改变

* HTTPS的加密原理，如何开启 HTTPS，如何劫持 HTTPS请求

* 理解 WebSocket协议的底层原理、与 HTTP的区别

### 3.设计模式

* 熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等

* 发布订阅模式和观察者模式的异同以及实际应用

* 可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用


## 四、数据结构和算法

### 1.JavaScript编码能力

* 多种方式实现数组去重、扁平化、对比优缺点
		  
   ES6方式
		1. 去除简单类型 
		Set 类似于数组，但是成员的值都是唯一的，没有重复值
		Set 方法 Set本身是一个构造函数，用来生成Set数据结构。
		Array.from:允许JavaScript集合如（如数组，类数组对象或者字符串，map，set等可迭代对象）上进行有用的转换
		
		
``` js
		let data = [1,2,3,1,2,3]
		function unique(array){
			return Array.from(new Set(array))
		}
		console.log(unique(data))
```


		2. 去除引用类型 reduce 方法
``` js		
		arr.reduce(callback,[initialValue])
		callback <!-- 包含四个参数-->
		previousValue<!-- 上一次调用回调返回的值，或者是提供初始值（initialValue -->
		currentValue <!-- 数组中当前被处理的元素-->
		index <!-- 当前元素在数组中的索引-->
		array <!-- 调用reduce的数组-->
		
		let array = [{
			"name":"A",
			"age":12
		},{
			"name":"A",
			"age":12
		},{
			"name":"B",
			"age":14
		}]
		
		var hash = {};
			
		array = array.reduce(function(itemPre,current){
			hash[current.name]?'':hash[current.name] = true && itemPre.push(current)
			return itemPre
		},[])
			
		console.log(array)
		
```

* 多种方式实现深拷贝、对比优缺点


* 手写函数柯里化工具函数、并理解其应用场景和优势


* 手写防抖和节流工具函数、并理解其内部原理和应用场景

	防抖： 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时
	
	
	
	节流： 规定在的单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效


* 实现一个 sleep函数

### 2.手动实现前端轮子

* 手动实现 call、apply、bind


* 手动实现符合 Promise/A+规范的 Promise、手动实现 asyncawait


* 手写一个 EventEmitter实现事件发布、订阅


* 可以说出两种实现双向绑定的方案、可以手动实现


* 手写 JSON.stringify、 JSON.parse


* 手写一个模版引擎，并能解释其中原理


* 手写 懒加载、 下拉刷新、 上拉加载、 预加载等效果

### 3.数据结构

* 理解常见数据结构的特点，以及他们在不同场景下使用的优缺点
    
   数据结构:
  
      栈：
        栈是一种特殊的线性表，仅仅能够在栈顶操作，先进后出，后进先出(LIFO)
      
      队列：
        栈是一种特殊的线性表，与栈相反遵循先进先出原则的一组有序的项
      
      链表：
        链表是物理存储单元上非连续的，非顺序的存储结构，由一系列节点组成
        节点：包括两部分一部分是存储数据元素的数据域，另外一部分是存储指向下一个节点的指针域
        首尾节点：链表的第一个节点是首节点，最后一个节点是尾节点
        
        有头链表和无头链表
        无头链表：第一个节点既有数据域，又有指针域，第一个节点即是首节点又是头节点
        有头链表：第一个节点只有指针域，没有数据域
              
      树：
        树是一种非线性的数据结构，由n(n>=0)个节点组成的集合
        if n=0,是一棵空树
        if n>0, 树有一个特殊的节点，这个节点没有父节点，称为根节点(root) 
        除根节点之外的其余数据元素被分为 m(m>=0) 个互不相交的集合 T1，T2，....Tm-1，其中每一个集合Ti(1<=i<=m) 本身也是一棵树，被称作为原树的子树
        
        节点：包含数据项，和指向其他节点的指针
        节点的度：节点所拥有的子树的数量
        
![度](../selfChecking/tree.png)


        叶节点：度为0的节点被称为叶节点
        分支节点：除去叶节点的节点就是分支节点
        子女节点：若节点x有子树，则这子树的根节点就是节点x的子女节点
        父节点：若节点x有子树，则这x为子女节点的父节点
        兄弟节点：同一个父节点的子女节点互相称为兄弟
        祖先节点：从根节点到该节点所见过分支上的所有节点
        子女节点：某一个节点的子女，以及这些子女的子女都是该节点的子孙节点
        节点所在层次：根节点在第一层，它的子女 在第二层
        树的深度：树中距离根节点最远的节点所处的层次就是树的深度
        树的高度：叶节点的高度为1，非叶节点的高度就是他的子女节点高度的最大值加1，高度与深度数值相等，但计算方式不一样
        树的度：树中节点的度的最大值
        有序树：树中节点的各棵字树T1，T2...是有持续的，T1是第一棵子树，T2是第2棵子树
        无序树：树中节点的各棵子树之间的次序不重要，可以互相交换位置
        森林：森林是m(m>0)棵树的集合（森林的树增加根节点可以变成一棵树，同样删除根节点就变成了森林）
        
        二叉树：二叉树是树的一种特殊情况，每个节点最多有两个子女，分别称为该节点的左节点和右节点。
               在二叉树中，不存在度大于2的节点。二叉树的子树有左右之分，次序不能颠倒。
			   性质：
		
		  特殊二叉树：
			  满二叉树：深度为k的满二叉树，是有个节点的二叉树，每一层都达到了可以容纳的最大数量的节点
		
				完全二叉树：深度为k的完全二叉树，从第一层到第 都是满的，第k层，
					
      堆：
				用数组实现的二叉树，所以没有父指针或者子指针。堆根据 “堆属性” 来排序，“堆属性”决定了树中节点的位置。堆是最高效的一种数据结构
      
      图：
				图是顶点集合（vertex）和顶点间的关系（edge）组成的一种数据结构：Graph=（V，E）
			 
				有向图：顶点对<x,y>是有序的，<x,y>是从顶点x到顶点y的一条有向边，顶点x是顶点，顶点y是终点，<x,y>与<y,x>是两条不同的边。
				无向图：顶点对(x,y)是无序的，(x,y)和(x,y)是同一条边。
				完全图：一个无向图有n个顶点，有n(n-1)/2条边，那么它就是无向完全图，一个有向图中，有n个顶点，有n(n-1)条边，则是有向完全图。
		
			权：边具有与之相关的数值，可以表示从一个顶点到另一个顶点的距离，耗费的时间，这个数值称为权重
		
			邻接顶点：在无向图中，一条边是(u,v),那么u和v互为邻接顶点，在有向图，是一条边，那么顶点u邻接到顶点v，顶点v邻接自顶点u
		
		
			度： 与顶点v关联的边数称为度。在有向图中，以v为终点的有向边的数量是v的入度，以v为始点有向边的数量为出度，v的度是入度和出度之和
			路径： 从顶点vi 出发，沿着一些边经过vp1, vp2 ,..., vpm 到达vj，则称（vi， vp1, vp2 ,..., vpm， vj）是从顶点vi到vj的一条路径。

			
		
      集合：
      
      BitMap(位图)：
           
        用一个bit位来标记某个元素所对应的Value，而key即是该元素
        基于位(Bit)做映射，能够用很少的内存存储数据，和数组不一样的是它只能存储表示某个数是否存在，可用于大数据去重，大数据排序，两个集合取交集
        BitMap 在处理大数据时候有优势，要求数据集紧凑，最大的值决定了BitMap要用多少内存
      

* 理解 数组、 字符串的存储原理，并熟练应用他们解决问题


* 理解 二叉树、 栈、 队列、 哈希表的基本结构和特点，并可以应用它解决问题


* 了解 图、 堆的基本结构和使用场景

### 4.算法

* 可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗


* 至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度


* 了解递归和循环的优缺点、应用场景、并可在开发中熟练应用


* 可应用 回溯算法、 贪心算法、 分治算法、 动态规划等解决复杂问题


* 前端处理海量数据的算法方案



## 五、运行环境

### 1.浏览器API

* 浏览器提供的符合 W3C标准的 DOM操作 API、浏览器差异、兼容性


* 浏览器提供的浏览器对象模型 ( BOM)提供的所有全局 API、浏览器差异、兼容性


* 大量 DOM操作、海量数据的性能优化(合并操作、 Diff、 requestAnimationFrame等)


* 浏览器海量数据存储、操作性能优化


* DOM事件流的具体实现机制、不同浏览器的差异、事件代理


* 前端发起网络请求的几种方式及其底层实现、可以手写原生 ajax、 fetch、可以熟练使用第三方库


* 浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型


* 浏览器提供的几种存储机制、优缺点、开发中正确的选择


* 浏览器跨标签通信


### 2.浏览器原理

* 各浏览器使用的 JavaScript引擎以及它们的异同点、如何在代码中进行区分


* 请求数据到请求结束与服务器进行了几次交互


* 可详细描述浏览器从输入 URL到页面展现的详细过程


* 浏览器解析 HTML代码的原理，以及构建 DOM树的流程


* 浏览器如何解析 CSS规则，并将其应用到 DOM树上


* 浏览器如何将解析好的带有样式的 DOM树进行绘制


* 浏览器的运行机制，如何配置资源异步同步加载


* 浏览器回流与重绘的底层原理，引发原因，如何有效避免


* 浏览器的垃圾回收机制，如何避免内存泄漏


* 浏览器采用的缓存方案，如何选择和控制合适的缓存方案


### 3.Node

* 理解 Node在应用程序中的作用，可以使用 Node搭建前端运行环境、使用 Node操作文件、操作数据库等等


* 掌握一种 Node开发框架，如 Express， Express和 Koa的区别


* 熟练使用 Node提供的 API如 Path、 Http、 ChildProcess等并理解其实现原理



* Node的底层运行原理、和浏览器的异同


* Node事件驱动、非阻塞机制的实现原理


##  六、框架和类库

### 1.TypeScript

* 理解 泛型、 接口等面向对象的相关概念， TypeScript对面向对象理念的实现


* 理解使用 TypeScript的好处，掌握 TypeScript基础语法


* TypeScript的规则检测原理


* 可以在 React、 Vue等框架中使用 TypeScript进行开发

### 2.React

* React和 vue选型和优缺点、核心架构的区别


* React中 setState的执行机制，如何有效的管理状态



* React的事件底层实现机制


* React的虚拟 DOM和 Diff算法的内部实现


* React的 Fiber工作原理，解决了什么问题


* ReactRouter和 VueRouter的底层实现原理、动态加载实现原理


* 可熟练应用 ReactAPI、生命周期等，可应用 HOC、 render props、 Hooks等高阶用法解决问题


* 基于 React的特性和原理，可以手动实现一个简单的 React

### 3.Vue

* 熟练使用 Vue的 API、生命周期、钩子函数


* MVVM框架设计理念


* Vue双向绑定实现原理、 Diff算法的内部实现


* Vue的事件机制


* 从 template转换成真实 DOM的实现机制

### 4.多端开发

* 单页面应用（ SPA）的原理和优缺点，掌握一种快速开发 SPA的方案


* 理解 Viewport、 em、 rem的原理和用法，分辨率、 px、 ppi、 dpi、 dp的区别和实际应用


* 移动端页面适配解决方案、不同机型适配方案


* 掌握一种 JavaScript移动客户端开发技术，如 ReactNative：可以搭建 ReactNative开发环境，熟练进行开发，可理解 ReactNative的运作原理，不同端适配


* 掌握一种 JavaScript PC客户端开发技术，如 Electron：可搭建 Electron开发环境，熟练进行开发，可理解 Electron的运作原理


* 掌握一种小程序开发框架或原生小程序开发


* 理解多端框架的内部实现原理，至少了解一个多端框架的使用

### 5.数据流管理

* 掌握 React和 Vue传统的跨组件通信方案，对比采用数据流管理框架的异同


* 熟练使用 Redux管理数据流，并理解其实现原理，中间件实现原理


* 熟练使用 Mobx管理数据流，并理解其实现原理，相比 Redux有什么优势


* 熟练使用 Vuex管理数据流，并理解其实现原理


* 以上数据流方案的异同和优缺点，不情况下的技术选型

### 6.实用库

* 至少掌握一种 UI组件框架，如 antd design，理解其设计理念、底层实现


* 掌握一种图表绘制框架，如 Echart，理解其设计理念、底层实现，可以自己实现图表
    
  Echart 设计理念
    
    
    
* 掌握一种 GIS开发框架，如百度地图 API


* 掌握一种可视化开发框架，如 Three.js、 D3


* 工具函数库，如 lodash、 underscore、 moment等，理解使用的工具类或工具函数的具体实现原理


## 七、前端工程

### 1.项目构建

* 理解 npm、 yarn依赖包管理的原理，两者的区别

* 可以使用 npm运行自定义脚本

* 理解 Babel、 ESLint、 webpack等工具在项目中承担的作用

* ESLint规则检测原理，常用的 ESLint配置

* Babel的核心原理，可以自己编写一个 Babel插件

* 可以配置一种前端代码兼容方案，如 Polyfill

*  Webpack的编译原理、构建流程、热更新原理， chunk、 bundle和 module的区别和应用

* 可熟练配置已有的 loaders和 plugins解决问题，可以自己编写 loaders和 plugins

### 2.nginx

* 正向代理与反向代理的特点和实例
    
   正向代理特点：客户端非常明确要访问的服务器地址。正向代理模式屏蔽或者隐藏了真是客户端信息
   
   用途：
   
    1.访问原来无法访问的资源，如Google

    2.可以做缓存，加速访问资源

    3.对客户端访问授权，上网进行认证

    4.代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息
    
    反向代理对外是透明的，访问者并不知道直接访问的一个代理。所以客户端不需要任何配置就可以访问
    
    用途：
    
    保证内网的安全，通常将反向代理作为公网访问地址，Web服务器是内网

负载均衡，通过反向代理服务器来优化网站的负载
    

* 可手动搭建一个简单的 nginx服务器、

* 熟练应用常用的 nginx内置变量，掌握常用的匹配规则写法

* 可以用 nginx实现请求过滤、配置 gzip、负载均衡等，并能解释其内部原理

### 3.开发提速

* 熟练掌握一种接口管理、接口 mock工具的使用，如 yapi

* 掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题

* 理解 TDD与 BDD模式，至少会使用一种前端单元测试框架

### 4.版本控制

* 理解 Git的核心原理、工作流程、和 SVN的区别
	
Git的核心原理

	(本地)
	1.工作区：当前进行工作区域，是文件系统的概念	 工作目录就是执行git init的地方
	2.暂存区：记录下次要提交将要保存到版本库中的文件  在.git 目录下
	3.版本库：记录工程某次提交的完整状态和内容，意味着该数据永远不会丢失 在.git 目录下
	
	所有文件只处于其中一个状态（本地）
	已修改 (modified)： 表示已修改但是没有保存到数据库，处于本地的工作区
	已暂存(staged)： 表示对已修改的文件的当前版本做标识，让它包含在下一次提交的快照中 ，处于暂存区
	已提交(committed)： 表示完成修改并保存到本地数据库中，处于已提交域
	
	处理结束再将本地仓库的最新状态文件快照 推送到远程仓库	(中心服务器)
	

Git的工作流程

	1.在本地工作区/工作目录中修改文件，文件modified
	2.暂存文件，add 把文件快照放入暂存区域，处于等待状态
	3.commit并push 找到暂存区域文件，并将快照永久性的存储到Git远程仓库

Git和 SVN的区别
	
	1.非集中式存储
	
	传统的SVN(集中式版本控制)要依赖特定的服务器实现版本管理功能，SVN必须联网才能正常工作。如果宕机一段时间 服务器崩溃情况 在这期间开发很难正在工作的版本上合作或者保存某一个版本的改变，或者中央数据库的磁盘出现问题但是没有备份导致丢失文件。解决方案把所有人的本地代码合并得到完整的版本但是将会会丢失历史版本/日志。
	
	
	Git (分布式版本控制) 不依赖特定的服务器完成功能 客户端不仅仅是检查文件的最新快照[完全镜像的存储库也就是本地有仓库]所以如果出现一样的情况，任何一个客户端仓库都可以备份到服务器来恢复数据。所以每一个clone是所有数据的完整备份 除了没有push的代码。另外Git 是支持离线工作，在本地可以进行很多操作，例如提交文件，查看历史版本记录，分支功能等。
	
	2.分支方面
	
	在版本管理方面，分支是最常见的使用功能。例如开发分支，稳定分支等等
	
	SVN 是没有本地分支。在SVN中分支就是一个完整的目录，且这个目录有完整的实际文件。如果想知道是否合并某一个分支 只需要手动运行 命令svn:mergeinfo 来确认分支是否被合并。而Git 分支是指针指向某次提交,处理Git分支可以在同一个工作目录下快速在几个分支切换。SVN 有一个switch功能，可以在同一个工作树上使用switch 在不同分支切换
	
	3.存储方式
	
	Git把内容按元数据方式存储，SVN 按文件存储。因为.git 目录是除于机器上的一个克隆版的版本库，包含中心版本库所有东西例如分支，版本记录等等。所以.git目录体积大小跟.svn区别很大
	
	4.全局版本号和全球版本号
	
	SVN 具有全局版本号，因为SVN是集中式版本控制所以容易实现版本号的连续性，基本可以预判下一个版本号
	
	Git 没有全局版本号，Git是分布式版本控制，Git 采用的是40位长的哈希值作为版本号，每个人的提交都是各自独立完成，也因为提交有先后顺序但是push/pull的时机不一致，所以没有先后之分。另外使用哈希值版本号不会出现重复，保证数据的完整性。因为哈希值是根据内容或者目录结构计算出来的
	
	Git 版本号简化: Git 可以使用从左面开始任意长度的字串作为简化版本号，只要该简化的版本号不产生歧义。一般采用7位的短版本号（只要不会出现重复的，也可以使用更短的版本号）。 Git 还可以使用 tag 来创建别名，即里程碑。
	
	5.版本库和工作区
	
	SVN的版本库和工作区是物理上是分开的，存储在不同的路径上，一般是在不同的主机上。而在企业级部署版本库在服务器上，只能通过协议访问，而不能直接被用户接触到。
	
	Git 的版本库和工作区是在同一个目录，工作区的根目录有一个.git（版本库本身，用来保存元数据和对象数据库的地方）的子目录，每次clone镜像仓库时候，实际copy的就是这个目录的数据。工作区的其他文件为工作区文件。
	版本库可以脱离工作区存在，成为bare版本库，但是工作区不能脱离版本库存在，所以工作区的根目录必须有一个.git的版本库克隆文件。
	因为Git的版本库在工作区能够直接被用户接触，所以用户可以直接修改.git/*文件，例如编辑.git/config 修改配置等，添加.git/ignore 创建本地忽略文件
	
	6.权限管理
	
	SVN 通过对文件目录的授权实现权限管理，子目录默认继承父目录权限。但是权限不能再分支中继承也不能对单个文件授权。
	
	Git授权只有 有或没有的授权。意思要么拥有全部的写权限，要么没有写权限。
	所以关于授权可以通过公司内部代码开放，或者对代码库进行分解，分别授权等
	
	7.操作方面
	
		7.1 checkout
			
		SVN 可以将整个或者部分目录检出到工作区（git 每个子目录下都有单独的.svn目录）
		Git 没有部分检出，但可以通过git工具 去浏览git库的功率。Git-submodule 可以实现版本库的模块化，例如子模块允许将一个git仓库当做另外一个git仓库的子目录。（git的本地仓库信息完全尾货在根目录的.git目录）
		
		7.2 update
		
		SVN 只有一个中心仓库，所以svn update 可以使工作区和版本库保持同步
		Git 通常是开发改动都是在远程仓库上，所以使用git fetch【将远程数据库的obkect copy到locol 然后更新remotes head 的refs】和git pull【在git fetch的基础上对当前分支加merge操作】远程更新
		
		7.3 撤销
		
		SVN 是属于集中式的版本控制，不能允许个人对已提交的数据进行篡改。SVN具有一个非常重要的特性就是它的信息从不丢失，即使当你删除了文件或目录，它也许从最新版本中消失了 ，但这个对象依然存在于历史的早期版本中。所以对远程仓库的数据提交就不能从客户端撤掉，只能在后续的提交中回退或者修改。
		
		Git 是分布式版本控制系统，代码库属于个人，Git可以放弃最新的提交，使用git reset/rebase修改或者重构历史提交
		
		8. 优缺点(https://www.cnblogs.com/wx1993/p/7680877.html)
		
		SVN 优点： 
		
		1、 管理方便，逻辑明确，符合一般人思维习惯。 

		2、 易于管理，集中式服务器更能保证安全性。 

		3、 代码一致性非常高。 

		4、 适合开发人数不多的项目开发。 

		SVN 缺点： 

		1、 服务器压力太大，数据库容量暴增。 

		2、 如果不能连接到服务器上，基本上不可以工作。

		3、 不适合开源开发（开发人数非常非常多，但是Google app engine就是用svn的）。但是一般集中式管理的有非常明确的权限管理机制（例如分支访问限制），可以实现分层管理，从而很好的解决开发人数众多的问题。
		
		
		Git 优点： 

		1、适合分布式开发，强调个体。 

		2、公共服务器压力和数据量都不会太大。 

		3、速度快、灵活。 

		4、任意两个开发者之间可以很容易的解决冲突。 

		5、离线工作。 

		Git 缺点： 

		1、学习周期相对而言比较长。 

		2、不符合常规思维。 

		3、代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。
		
	
* 熟练使用常规的 Git命令、 git rebase、 git stash等进阶命令
		
常规Git命令：
		
		git help(查看帮助命令)
		
		git clone (克隆远程的地址下载到本地)
		
		git init (初始化仓库)
		
		git branch (显示所有分支)
		
		git branch -d <branchname>(删除分支)
		
		git checkout mater (去到master这个分支)
		
		git checkout -b mybranch(创建并切换分支)
				
		git checkout -b mybranch origin/mybranch(取远程分支并分化一个新分支)
		
		git pull origin master(拉取master)
		
		git checkout -b ldj2 (在master下创建一个名为 ldj2的分支)
		
		git checkout -b ldj2 ldj3 (在master下的ldj2分支下创建一个名为ldj3的分支)
		
		git status (查看当前文件状态)
		
		git diff filename （查看filename这个文件做的那些修改）
		
		git add filename (添加要提交的文件)
		
		git commit -m “write you annotation here” (提交，引号里面写注释)
		
		git push(上传本地所有分支代码到远程对应的分支上。)
		
		git push origin master(传本地当前分支代码到master分支)
		
		git merge origin/maste(把远程下载下来的代码合并到本地仓库，远程的和本地的合并)
		
		git remote -v(查询当前远程的版本)
		
		git fetch origin master(从远程获取最新版本到本地)
		
git rebase:(变基其实也是一种合并分支的方法【个人用的特别的少】变基的作用就是修整历史，将分支历史并入主线。)
		
[git rebase使用笔记](https://www.jianshu.com/p/cca69cb695a6)
		
		合并多次提交记录：
		
			git rebase -i HEAD~4 (合并最近的 4 次提交纪录)
			git rebase --edit-todo (去到编辑的模式)
			git rebase --continue (继续编辑 修改保存)
			git log (查看结果)
		
		分支合并：
		
			git:(feature1) git rebase master 
			1. git 会把 feature1 分支里面的每个 commit 取消掉
			2. 上面的操作临时保存成 patch 文件，存在 .git/rebase 目录下
			3. 把 feature1 分支更新到最新的 master 分支；
			4. 把上面保存的 patch 文件应用到 feature1 分支上
			
			在 rebase 的过程中，也许会出现冲突。通常git 会停止 rebase 并去解决冲突。
			在解决完冲突后，用 git add 命令去更新这些内容。
			这时候不需要用git commit 只需要执行 git rebase--continue
			git 会继续应用余下的 patch 补丁文件
			
			任何时候 都可以使用
			git rebase —abort (终止 rebase 的行动，并且分支会回到 rebase 开始前的状态。)
		
git stash:用于保存和恢复工作进度 (这个命令很有效)
		
		git stash(保存当前的工作进度。会分别对暂存区和工作区的状态进行保存)		
				
		git stash save "message..."	(这条命令实际上是第一条 git stash 命令的完整版)	
		
		git stash list(显示进度列表。此命令显然暗示了git stash 可以多次保存工作进度，并用在恢复时候进行选择)	
			
		git stash pop [--index] [<stash>]	(如果不使用任何参数，会恢复最新保存的工作进度，并将恢复的工作进度从存储的工作进度列表中清除。		
		如果提供参数（来自 git stash list 显示的列表），则从该 <stash> 中恢复。恢复完毕也将从进度列表中删除 <stash>。		
		选项--index 除了恢复工作区的文件外，还尝试恢复暂存区。)	
			
		git stash apply [--index] [<stash>]	(除了不删除恢复的进度之外，其余和 git stash pop 命令一样)	
				
		git stash clear	(删除所有存储的进度)
				

* 可以快速解决 线上分支回滚、 线上分支错误合并等复杂问题

      线上分支回滚：
      
        1. 删除远程分支再提交
            
            
        2. 强制push远程分支
            
            
        3. 从回滚位置生成新的commit hash


        4. 从回滚位置生成新的分支merge


### 5.持续集成

* 理解 CI/CD技术的意义，至少熟练掌握一种 CI/CD工具的使用，如 Jenkins

	CI:持续集成(Continuous Integration)   
	CD:持续交付(Continuous Delivery)
	Jenkins 是一个开源的，提供友好操作界面的持续集成工具(CI)
	
	
	
	

* 可以独自完成架构设计、技术选型、环境搭建、全流程开发、部署上线等一套完整的开发流程（包括 Web应用、移动客户端应用、 PC客户端应用、小程序、 H5等等）

## 八、项目和业务

### 1.后端技能

* 了解后端的开发方式，在应用程序中的作用，至少会使用一种后端语言

* 掌握数据最终在数据库中是如何落地存储的，能看懂表结构设计、表之间的关联，至少会使用一种数据库

### 2.性能优化

* 了解前端性能衡量指标、性能监控要点，掌握一种前端性能监控方案

* 了解常见的 Web、 App性能优化方案

*  SEO排名规则、 SEO优化方案、前后端分离的 SEO

*  SSR实现方案、优缺点、及其性能优化

*  Webpack的性能优化方案

*  Canvas性能优化方案

*  React、 Vue等框架使用性能优化方案

### 3.前端安全

*  XSS攻击的原理、分类、具体案例，前端如何防御

*  CSRF攻击的原理、具体案例，前端如何防御

*  HTTP劫持、页面劫持的原理、防御措施
















### 4.业务相关

* 能理解所开发项目的整体业务形态、业务目标、业务架构，可以快速定位线上业务问题

* 能理解所开发项目整体的技术架构、能快读的根据新需求进行开发规划、能快速根据业务报警、线上日志等定位并解决线上技术问题

* 可以将自己的想法或新技术在业务中落地实践，尽量在团队中拥有一定的不可替代性






